from ltlf2dfa.parser.ltlf import *

__p = LTLfParser()

Existence = lambda x: __p(f"F({x})")
Absence = lambda x: __p(f"!F({x})")
Init = lambda x: __p(f"{x}")
Last = lambda x: __p(f"F({x} & X(! true))")
Choice = lambda x, y: __p(f"F({x}) | F({y})")
ExclusiveChoice = lambda x, y: __p(f"(F({x}) | F({y})) & !(F({x}) & F({y}))")
RespondedExistence = lambda x, y: __p(f"F({x}) -> F({y})")
CoExistence = lambda x, y: LTLfAnd([RespondedExistence(x,y), RespondedExistence(y,x)])
Response = lambda x, y: __p(f"G({x}) -> F({y})")
AlternateResponse = lambda x, y: __p(f"G({x} -> X(!{x} U {y}))")
ChainResponse = lambda x, y: __p(f"G({x}) -> X({y}))")
Precedence = lambda x, y: __p(f"!{y} W {x}")
AlternatePrecedence = lambda x, y: __p(f"(!{y} W {x}) & G({y} -> (!{y} W {x}))")
ChainPrecedence = lambda x, y: __p(f"G(X({y}) -> {x})")
Succession = lambda x, y: LTLfAlways(LTLfAnd([Response(x,y), Precedence(x,y)]))
AlternateSuccession = lambda x, y: LTLfAlways(LTLfAnd([AlternateResponse(x,y), AlternatePrecedence(x,y)]))
ChainSuccession = lambda x, y: LTLfAlways(LTLfAnd([ChainResponse(x,y), ChainPrecedence(x,y)]))
NotCoExistence = lambda x, y: __p(f"(F({x}) -> !F({y})) & (F({y}) -> !F({x}))")
NotSuccession = lambda x, y: __p(f"G({x}) -> !F({y})")
NotChainSuccession = lambda x, y: __p(f"G({x} -> !X({y}))")